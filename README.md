# NomadCoders TodoList Competition

TodoList 컨테스트에 참가하기 위해 시작한 Vanilla Javascript 프로젝트

* [대회 공지](https://nomadcoders.co/community/thread/182)

* [대회 결과](https://nomadcoders.co/community/thread/452)

![image](https://user-images.githubusercontent.com/67461578/110208724-386c9380-7ecc-11eb-9a20-63cf4ba3c760.png)

무려 🏆**인기상**에 당첨이 되었다! ~*(치킨 감사합니다!)*~

이 프로젝트에 투표해주신 모든 분들께 이 자리를 빌려 감사의 말씀을 드린다.

---

<br />

[프로젝트 링크](https://pshtony1.github.io/noamd-todo-competition/)

<img src="https://user-images.githubusercontent.com/67461578/110208885-00b21b80-7ecd-11eb-8eb8-958cbf04ecc7.png" width="50%" /><img src="https://user-images.githubusercontent.com/67461578/110208916-1cb5bd00-7ecd-11eb-864e-4a13cfcb4cc0.png" width="50%" />

---

<br />

## 1. 스택

**Only Vanilla Javascript + Front-end**

<img src="https://img.shields.io/badge/Javascript-1f232a?style=flat-square&logo=JavaSCript&logoColor=f0db4f" height="30px" /> 

**서드 파티는 일체 사용하지 않았다.**

<br />

## 2. 기능

이하는 현재 모두 구현된 기능들이다.

**모든 데이터는 자동으로 `LocalStorage`에 저장된다.**

### 2 - 1. 유저 🙍‍♂️

* Display name 설정(최초 1회) &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#display-name-%EC%84%A4%EC%A0%95)

* 로그아웃(데이터 초기화)

### 2 - 2. 카드 📝

* 카드 생성 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%EC%B9%B4%EB%93%9C-%EC%83%9D%EC%84%B1--%ED%83%9C%EA%B7%B8-%EC%83%9D%EC%84%B1)

* 카드 삭제 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%EC%B9%B4%EB%93%9C-%EC%82%AD%EC%A0%9C)

* 카드 수정 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%EC%B9%B4%EB%93%9C-%EC%88%98%EC%A0%95)

* 카드 검색(기준: 카드 내용)

* 카드 상태변경 ( `Todo` - `Complete` ) &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%EC%B9%B4%EB%93%9C-%EC%83%81%ED%83%9C%EB%B3%80%EA%B2%BD--todo-%EC%A7%84%EC%B2%99%EB%8F%84)

* 카운트 다운(최대 24시간)

* 카드 최상단 고정 기능 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%EC%B9%B4%EB%93%9C-%EC%B5%9C%EC%83%81%EB%8B%A8-%EA%B3%A0%EC%A0%95)

### 2 - 3. 해시태그 🏷

* 각 카드에 해시태그 부여 가능(개수 제한 X) &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%EC%B9%B4%EB%93%9C-%EC%83%9D%EC%84%B1--%ED%83%9C%EA%B7%B8-%EC%83%9D%EC%84%B1)

* 해시태그 필터링 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%ED%95%B4%EC%8B%9C%ED%83%9C%EA%B7%B8-%ED%95%84%ED%84%B0%EB%A7%81)

* 태그 색 수정 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%ED%83%9C%EA%B7%B8-%EC%83%89-%EC%88%98%EC%A0%95)

* 태그 삭제 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%ED%83%9C%EA%B7%B8-%EC%82%AD%EC%A0%9C)

### 2 - 4. 프로필 😎

* 각종 메뉴

* Todo 진척도 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%EC%B9%B4%EB%93%9C-%EC%83%81%ED%83%9C%EB%B3%80%EA%B2%BD--todo-%EC%A7%84%EC%B2%99%EB%8F%84)

* 프로필 숨기기 가능 &nbsp; [미리보기](https://github.com/pshtony1/noamd-todo-competition/#%ED%94%84%EB%A1%9C%ED%95%84-%EC%88%A8%EA%B8%B0%EA%B8%B0-%EA%B8%B0%EB%8A%A5--%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EB%86%92%EC%9D%B4-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%9E%90%EB%8F%99-%EC%88%A8%EA%B8%B0%EA%B8%B0)
  * **디바이스 높이를 고려하여 자동으로 프로필이 숨겨짐(디바이스 높이 1000px 미만 시)**

### 2 - 5. 기타 🎸

* 언어 변경 지원(한국어, 영어)

<br />

## 3. 개발 비하인드

### 프로젝트 기간 📅
* 프로젝트 시작 👉 **2021년 2월 2일**
  
* 프로젝트 종료 👍 **2021년 2월 10일**
  
대략 일주일 남짓 걸렸다.

### 느낀 것
* 정말 천국과 지옥의 반복이었다. 막상 구현하고 싶은 기능은 많은데, 바닐라로 구현하려니 막막했다.
  * **나만 이걸 해결할 수 있다**는 마인드로 접근해서 끝까지 물고 늘어졌고, 구현이 다 된 모습을 보면 정말 황홀했다.

* 확장성, 재사용성등을 고려해서 `ES6`의 `module`과 `class`를 이용해 분할정복하며 구현했고, 덕분에 코드 재사용성/확장성이 대폭으로 상승한 것을 직접 체감했다.

* `클로저`가 정말 좋은 기능이라는 것을 느꼈다. 이전까지는 콜백함수에 일일히 바인딩을 해서 `this`를 유지시켰는데, `클로저`를 사용함으로써 수고를 많이 덜었다. 

* 정말 `React`가 생산성에 있어서 얼마나 대단한 라이브러리인지 깨달았다. 😭
  * `React`로 만들었다면 일주일은 커녕 3일도 안 걸렸을것이다.
  * 만드는 내내 `React`의 `Hooks`, 생명 주기, `JSX`, 컴포넌트가 그리웠다.

* `React`로 넘어가기전, 많은 개발자들이 바닐라를 만져보면서 왜 `React`가 필요한지 몸으로 느껴보라고 했는데 왜 그랬는지 알 것 같다.

* 구현하면서 가장 힘들었던 순서는 **이벤트 > 해시태그 구현 > 부드러운 애니메이션 전환 > 나머지** 였다.

<br />

## 4. 문제 및 해결

### 🙉 카드 각각에 고유한 ID를 부여하는 좋은 방법?

`LocalHost`에 저장된 카드에 접근하기 위한 식별자로 각 카드 데이터에 ID를 부여하기로 했다.  
그러나 ID를 어떤 기준으로 만들지 고민이 되었다.

단순하게 떠올린 생각으로는

```
1. ID를 중복되지 않는 1, 2, 3, 4... 로 부여하자.
2. 해시함수에 카드의 텍스트를 넣어서 나온 결과를 ID로 사용하자.
```

가 있었다.

그러나 이 두 방법은 전부 치명적인(?) 단점이 존재했다.

* 1번은 ID를 부여하는 구조를 효율적으로 짜게 되면 로직이 매우 복잡해진다는 것(+ 메모리도 사용해야 함), 단순하게 짠다고 하더라도 카드를 많이 생성한다면 ID의 크기가 무한히 커진다는 것.
* 2번은 같은 텍스트를 가진 카드가 존재한다면, 유일한 ID가 보장되지 않는다는 점.

이를 해결하기 위해 정말 좋은 아이디어를 떠올렸다.

### ✔ `Salt`를 이용해서 ID를 생성했다.

1. 10글자의 랜덤한 `Salt`를 생성했다.

```js
getSalt: () => {
  let salt = "";

  for (let i = 0; i < 10; i++) {
    if (Math.random() > 0.5) {
      const ascii = Math.floor(Math.random() * 26) + 97;
      const c = String.fromCharCode(ascii);
      salt += c;
    } else {
      salt += Math.floor(Math.random() * 10);
    }
  }

  return salt;
},
```

2. Hash 함수를 만들었다. 32bit의 정수로 변환하는 함수이다.

```js
createHash(str) {
  let hash = 0;
  let chr;

  for (let i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0; // Convert to 32bit integer
  }

  return hash;
},
```

3. 카드 텍스트와 `Salt`를 결합하여 고유한 ID를 생성했다!

```js
const toConvert = card.text + getSalt();
const id = createHash(toConvert);  // Unique ID! 
```

<br />

### 🙉 Modal을 효율적으로 재사용하고 싶었다.

카드 생성, 카드 수정, 해시태그 필터링 등등 여러 기능에 같은 Modal을 재사용하고 싶었다.  
`React`라면 state를 이용해 손쉽게 재사용이 가능했지만, 바닐라라 그렇기는 힘들었다.

### ✔ `setState`를 직접 만들었다.

1. modal Class에 `setState` 메서드를 추가했다. 

```js
setState(nextData) {
  this.data = nextData;

  ... 중략

  this.renderModal();
}
```

2. `renderModal` 메서드에서 `this.data`를 이용해 modal의 필요한 부분만 재렌더링한다.

```js
renderModal() {
  const {
    title,
    ...생략,
  } = this.data;
  
  // modal의 title 재렌더링
  const $modalTitle = this.$modalContainer.querySelector(
    ".modal-content__title"
  );
  $modalTitle.textContent = title;

  ... 중략
}
```

<br />

### 🙉 Node.cloneNode(true)가 Node의 EventListener까지 복사하지 않았다.

가령 카드의 상태를 `todo`에서 `complete`로 변화시킬 때, `todo` 상태인 카드의 element를 cloneNode를 이용해 **복사**하여 `complete`로 옮기는 로직이 있었다.

그런데 위와 같은 문제때문에 기존 카드에 있던 이벤트들이 전부 증발해버리는 문제가 생겼다.

### ✔ 어쩔 수 없이 하드코딩했다. 대신 클로저를 이용해 바인딩 문제를 쉽게 해결했다.

말 그대로 증발된 이벤트들을 전부 다시 적용해주었다.  
이 과정에서, `addEventListener`를 사용했기 때문에 이벤트들을 콜백함수의 형태로 넘겨주어야했다.

1. 추가할 이벤트들을 클로저의 형태로 미리 만들어두었다.

```js
function copyCardElement() {
  // 카드 수정 버튼에 적용될 이벤트
  function editButtonEL(e) {
    ... 생략
  }

  // 카드 상태변경 버튼에 적용될 이벤트
  function toggleStateButtonEL(e) {
    ... 생략
  }
}
```

2. 상태를 변경할 카드를 가져오고, cloneNode로 복사한 뒤 이벤트를 전부 적용해주었다.

```js
function copyCardElement() {
  // 카드 수정 버튼에 적용될 이벤트
  function editButtonEL(e) {
    ... 생략
  }

  // 카드 상태변경 버튼에 적용될 이벤트
  function toggleStateButtonEL(e) {
    ... 생략
  }
  
  const newCard = new Card();
  newCard.element = getChangedCard().element.cloneNode(true);
  
  const newCard_editButton = newCard.element.querySelector(".edit-button");
  newCard_editButton.addEventListener("click", editButtonEL);
  
  const newCard_toggleStateButton = newCard.element.querySelector(".toggle-button");
  newCard_toggleStateButton.addEventListener("click", toggleStateButtonEL);
  
  return newCard;
}

```

<br />

### 🙉 랜덤한 색으로 생성되는 태그의 텍스트가 보이지 않는 경우가 생겼다.

가령, 아래와 같이 밝은 색으로 태그의 색이 설정되어 버리면 태그의 텍스트가 보이지 않았다.

![image](https://user-images.githubusercontent.com/67461578/110213551-e899c680-7ee3-11eb-87fe-14708ce68749.png)![image](https://user-images.githubusercontent.com/67461578/110213630-2b5b9e80-7ee4-11eb-9946-78cc80bcda97.png)

이러한 경우에 텍스트의 색을 어둡게 만드는 로직을 추가할까 고민했지만,  
로직이 복잡해질 것 같았고 이것이 효율적인 해결 방법이 아닌 것 같았다.

그러다 좋은 아이디어를 발견했다.

### ✔ 태그 생성시, 태그 배경색의 alpha 값을 의도적으로 낮은 값으로 설정한다.

이것이 매우 효과적이었던 이유가 있다.

```
1. 기본적으로 프로젝트는 다크모드이기 때문에, alpha 값을 낮게 설정하면 그만큼 태그의 색도 어두워진다.
2. 태그의 텍스트가 태그 배경색에 비해 상대적으로 어두워진다.
```

다음은 태그 배경색의 alpha값에 따른 태그의 모습이다.

| alpha=1 | alpha=0.6 | alpha=0.2 |
| - | - | - |
| ![image](https://user-images.githubusercontent.com/67461578/110213833-1b908a00-7ee5-11eb-8242-6ead10b33900.png) | ![image](https://user-images.githubusercontent.com/67461578/110213846-2814e280-7ee5-11eb-8ab2-e8308512456f.png) | ![image](https://user-images.githubusercontent.com/67461578/110213859-3236e100-7ee5-11eb-9326-ec72feb4079a.png) |

정말 간단하게 문제를 해결할 수 있었다!

<br />

### 🙉 'element들의 애니메이션이 끝났을 때' 를 setTimeout으로 캐치했다.

이를 적용하기 전에, 구글링을 해보니 대부분의 Stackoverflow, 블로그, 포스트 등에서 `setTimeout`을 사용함을 알게되었다.

예를 들어,

```css
/* CSS */

.element {
  ... 중략
  opacity: 0;
  animation: customAnimation 0.5s linear forwards;
}

@keyframes customAnimation {
  from {
    opacity: 0;
  }
  
  to {
    opacity: 1;
  }
}
```

```js
// JS

const element = document.querySelector(".element");

// 애니메이션 종료 (css와 마찬가지로 0.5초로 설정)
setTimeout(whenAnimationEnd, 500);
```

처럼 말이다.

그래서 당연히 이것이 정석적인 방법인줄 알고있었다.

### ✔ 그러나, animationend 이벤트가 존재한다.

```js
// JS

const element = document.querySelector(".element");

// 애니메이션 종료이벤트
element.addEventListener("animationend", whenAnimationEnd);
```

이것을 알게된 후 멘탈이 나갈 뻔했다. 😭😭  
부족한 내 검색능력을 탓했다.

<br />
<br />
<br />

---

<br />

## 부록. 기능 미리보기

### 유저 🙍‍♂️

#### Display name 설정

![init1](https://user-images.githubusercontent.com/67461578/110209926-871d2c00-7ed2-11eb-90fc-b4554c324bce.gif)

<br />

### 카드 📝

#### 카드 생성 & 태그 생성

![create1](https://user-images.githubusercontent.com/67461578/110210022-01e64700-7ed3-11eb-924d-cada86ea56fd.gif)

#### 카드 수정

![edit1](https://user-images.githubusercontent.com/67461578/110210067-47a30f80-7ed3-11eb-9a77-f6915f41f697.gif)

#### 카드 삭제

![delete1](https://user-images.githubusercontent.com/67461578/110210124-9c468a80-7ed3-11eb-85b6-3f58fbae9be3.gif)

#### 카드 상태변경 && Todo 진척도

![statechange1](https://user-images.githubusercontent.com/67461578/110210263-2c84cf80-7ed4-11eb-9c42-306735c6958e.gif)

#### 카드 최상단 고정

![fixcard1](https://user-images.githubusercontent.com/67461578/110210375-b92f8d80-7ed4-11eb-88a9-49d6ac13d346.gif)

<br />

### 해시태그 🏷

#### 해시태그 필터링

![filter1](https://user-images.githubusercontent.com/67461578/110210617-c8630b00-7ed5-11eb-9e7c-1350cd4a9075.gif)

#### 태그 색 수정

![coloredit1](https://user-images.githubusercontent.com/67461578/110210710-44f5e980-7ed6-11eb-9383-d8416bccafab.gif)

#### 태그 삭제

![deletetag1](https://user-images.githubusercontent.com/67461578/110210728-622ab800-7ed6-11eb-8ad3-6edf2a18c45a.gif)

<br />

### 프로필 😎

#### 프로필 숨기기 기능 + 디바이스 높이 고려해 자동 숨기기

![hide1](https://user-images.githubusercontent.com/67461578/110210845-e5e4a480-7ed6-11eb-8a6d-2ccae5d242e9.gif)



